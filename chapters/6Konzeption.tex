\chapter{\label{chap:konzeption}Konzeption}
Die erarbeiteten Anforderungen zur Untersuchung der Konfliktmanagementstrategien offlinefähiger Systeme werden in diesem Kapitel für die Konzeption angewendet.\\
Es soll für jede zu untersuchende Technologie ein Prototyp entwickelt werden. Im Rahmen dieser Arbeit entsteht ein Prototyp der \sc{Redux Offline} verwendet und ein zweiter in dem PouchDB und CouchDB eingesetzt wird. Für letzteren könnte genausogut das Framework \sc{Hoodie} benutzt werden, da es sowohl PouchDB als auch CouchDB benutzt~\cite{hoodie-how}. Doch da für den zu entwickelnden Prototyp lediglich diese beiden Komponenten benötigt werden, wurde sich dagegen entschieden.
Bis zu einem gewissen Status, nämlich dem der Verwendung der Technologien, sind beide Prototypen -- bis auf den Namen-- identisch.
% Beginnend mit dem Aufbau der exemplarischen Anwendung werden in den folgenden Abschnitten die  der Anwendungsaufbau, Architektur  und schließlich \todo{blabla} die graphische Oberfläche aufgeführt.
% Den Raum aller möglichen Lösungen anhand der Anforderungen auf die in irgendeinem Sinn beste / geeignetste einzuschränken:\\
% App entwickeln, in der es einen `Verbindung unterbrechen` Knopf gibt ', oder ob es aus irgendwelchen Erwägungen notwendig sein könnte, das über eine separate Instanz zu machen.
%
% Aufbau
%
\section{Anwendungsaufbau}
Die Prototypen bestehen im Frontend aus React und wurden mit \sc{Create React App} erstellt. \sc{Create React App} erstellt ein Projekt mit dem gewünschten Namen, generiert eine initiale Projektstruktur (vgl. Abbildung \ref{fig:init}) und installiert die dafür benötigten Abhängigkeiten~cite{create-react}.
\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{0.4\textwidth}
          \includegraphics[width=\textwidth]{Ordnerstruktur}
          \caption{Die initiale Projektstruktur}
          \label{fig:init}
  \end{subfigure}
  ~ 
  \begin{subfigure}[t]{0.4\textwidth}
          \includegraphics[width=\textwidth]{rca-package}
          \caption{Die initiale package.json Datei}
          \label{fig:init2}
  \end{subfigure}
  \grayRule
  \caption[Create React App: initiale Testapplikation]{einer mit Create React App erstellten Testapplikation}
  \label{fig:create-react-app}
\end{figure}
Diese sind im Verzeichnis node\_modules installiert.
Außerdem ist ein ServiceWorker und ein App Manifest (\tt{manifest.json}) enthalten, wodurch die \gls{PWA}-- Kriterien erfüllt sind.
Als Template gibt es nun die \tt{public/index.html}-- Datei. In der \tt{index.js}--Datei werden die React--Komponenten und der ServiceWorker initialisiert.. Alle \tt{App.*}--Dateien umfassen eine minimale Beispielanwendung.
In der generierten \tt{package.json}--Datei (vgl. Abbildung \ref{fig:init2}), befinden sich Informationen über die Anwendung und ihre Abhängigkeiten. Im Unterpunkt \tt{scripts} werden Kommandozeilen-Aufrufe definiert und können mit dem Befehl \tt{npm} aufgerufen werden.
%
% React Komponenten
%
\input{chapters/6konzept/aufbau}
%
%
% Architektur
%
\section{Architektur}
Die zu erstellenden Prototypen erhalten die Namen \it{amilia-qouch} und \it{amilia-rdx}, wobei Amilia der Name ist, der sich in den Beispielkontakten in den Szenarien wiederfindet. Die Abkürzung \it{rdx} steht für Redux und zeigt, dass dieser Prototyp \sc{Redux Offline} verwendet. Die Endung \tt{qouch} soll die Symbiose von CouchDB und PouchDB darstellen. Der Buchstabe Q klingt wie das hart ausgesprochene C in Couch und wenn man das kleine Q horizontal spiegelt, sieht man das P für Pouch.\\\\
Beide Prototypen setzen sich aus den nachfolgend beschriebenen Komponenten zusammen, welche in Abbildung \ref{fig:uml} veranschaulicht werden.\\\\
Die Komponente \tt{Contacts} fungiert als Container und ist das Herzstück der Anwendung. Er definiert die graphische Oberfläche und stellt alle notwendigen Funktionen bereit. Sie hat einen internen \tt{state} in dem sowohl die Kontaktliste, als auch die Daten für das Formular gespeichert sind. Im Diagramm ist der \tt{state} an der blauen Schrift zu erkennen. Das Objekt \tt{editView} zeigt, welche Ansicht -- Liste oder Formular -- gerade aktuell ist und speichert den im Formular zu ladenden Kontakt. Wie das Kontaktobjekt aufgebaut ist zeigt der blaue Kasten im Diagramm. Wird eine Aktion zum Ändern der Ansicht aufgerufen, beispielsweise durch das Betätigen eines Knopfes, wird über die Funktion \tt{toggleEdit()} der interne \tt{state} aktualisiert und ein erneutes Rendern der Komponente eingeleitet. Dann wird entsprechend die Liste oder das Formular gerendert.\\
Die \tt{Header}--Komponente zeigt den Netzwerkstatus der Anwendung an und hat einen Knopf, der zum \tt{ContactForm} führt.\\
Die \tt{ContactList} wird initial gerendert. Es werden alle Kontakte als Liste dargestellt. Hier kann das Bearbeiten (\tt{handle"-On"-Edit"-Click()}) oder das Löschen (\tt{handle"-On"-De"-lete"-Click()}) des Kontakts eingeleitet werden.
\begin{figure}[H]
  \includegraphics[width=\textwidth]{uml}
  \grayRule
  \caption{Komponentenarchitektur}
  \label{fig:uml}
\end{figure}
Die Komponente \tt{ContactForm} zeigt, sofern vorhanden, alle im Kontakt gespeicherten Daten an. Diese können hier bearbeitet werden. Gibt es keine Kontaktdaten die geladen werden kann, kann hier ein neuer Kontakt angelegt werden. Zusätzlich zu den Eingabefeldern für jedes Kontaktattribut hat sie zwei Knöpfe mit denen die Aktion bestätigt (\tt{handleSubmit()}) oder abgebrochen (\tt{handleCancel()}) werden kann. Sie ist neben \tt{Contacs} die einzige Komponente mit einem internen \tt{state}. Dieser wird für die Ereignishandler benötigt, die auf die Veränderung der einzelnen Eingabefelder zu ``lauschen``. Der zu bearbeitende Kontakt wird hier zwischengespeichert und dann als Ganzes an \tt{Contacts} gegeben.\\
\todo{Konflikt--Dialog}\\\\
%
% 
%
\todo{Backend: Implementierung bei qouch nicht notwendig. Nur Installation von Couch.\\ 
Für Redux Offline: Server und JSON Datei als DB Ersatz? UND Redux- store, actions, Reducer}
% Client - Server - Modell
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{qouch-model}
  \grayRule
  \caption{Client-Server-Modell}
  \label{fig:qouch-model}
\end{figure}
%
% Lokale Speicherung
%
\sub{Lokales Speichern der Daten}
Das Seichern von Kontakten ist in den Prototypen unterschiedlich implementiert.
Die Idee hinter Redux Offline ist, dass der Redux Store die Datenbank ersetzt. Sobald der Appstatus sich ändert, wird er automatisch lokal gespeichert. Dazu wird \tt{redux-persist} benutzt, dessen Funktionsweise in Abschnitt \ref{sub:reduxpersist} erläutert wird. Der Redux Store wird bei jeder Änderung persistiert und beim Start der Anwendung neu geladen. Es bedarf keiner zusätzlichen Implementierung für die lokale Speicherung der Kontaktdaten.\\\\
Für den Prototypen \it{amilia-qouch} sind wenige Schritte notwendig. Das asynchrone \gls{API} von PouchDB stellt alle notwendigen Funktionen bereit die sowohl Callbacks, Promises als auch asynchrone Funktionen unterstützen. Die für den Prototypen benötigten werden anhand des Codeausschnitts \ref{code:pouch} ausgeführt.
Die lokale Datenbank wird in Zeile eins erstellt. Wenn es die Datenbank mit dem Namen `contacts` bereits gibt passiert nichts.
\begin{center}
  \lstinputlisting[language=REACT,
  firstline=1,lastline=21,
  numbers=left,xleftmargin=20pt,framexleftmargin=15pt,
  caption={Implementierung der von PouchDB bereitgestellten \gls{CRUD} Operationen}, 
  label=code:pouch]{code/Pouch.js}
\end{center}
Die Zeilen drei bis fünf zeigen wie ein Kontakt erzeugt werden kann. Bevor das geschieht wird die ID gesetzt. PouchDB bietet zur Erstellung von Objekten auch \tt{localDB.post()} an. Bei dessen Verwendung wird \tt{\_id} von PouchDB automatisch generiert. Diese Variante wird jedoch nicht empfohlen, weil dann die IDs zufällig sind, die Objekte nicht danach sortiert werden können~\cite{pouch-create}.\\
Das Aktualisieren eines Kontakts sieht ähnlich aus. Zuerst wird der entsprechende Kontakt wie in Zeile acht aus der Datenbank angefragt um dann in der Datenbank aktualisiert zu werden. Mit jedem Update bekommt ein Kontakt von PouchDB eine neue Revision.\\
Der Aufruf \tt{localDB.allDocs()} in Zeile 13 fragt alle in der lokalen Datenbank gespeicherten Kontakte an. Ohne den Parameter \tt{include\_docs: true} werden nur die \tt{\_id} und die \tt{\_rev} Eigenschaften eines jeden gespeicherten Kontakts zurückgegeben. Ist die Option \tt{conflicts} auf \tt{true} gesetzt, werden unter dem Attribut \tt{\_conflicts} Konfliktinformationen zu jedem Kontakt gespeichert.\\
Man kann einen Kontakt in PouchDB ganz einfach mittels \tt{localDB.remove(contact)} löschen. Dann ist das Kontaktdokument mit all seinen Feldern gelöscht. Die lokale Datenbank soll sich mit CouchDB synchronisieren. Ist die Revision eines gelöschten Kontakts nicht mehr vorhanden, kann diese nicht repliziert werden. Deswegen wird der Kontakt wie in Zeile 19 als gelöscht markiert und aktualisiert.
%
% Sync
%
\sub{Synchronisation}
% Redux Offline
\subsub{Synchronisation mit Redux Offline}
Redux Offline: Server der alle \gls{CRUD} Operationen unterstützt,
\gls{JSON}--Datei zur Persisierung um Ergebnisse nicht zu verfälschen 
Redux Offline: Idee: Store = Datenbank
% Pouch
\subsub{Synchronisation mit PouchDB}
CouchDB = RemoteDB\\
% -----------------------------------------------------------------------------
%
% Online / Offline
%
\sub{Verbindungsstatus feststellen und ändern}
Für die Überprüfung der Verbindung zum Server wird das Modus \sc{React Detect Offline} verwendet. Es beobachtet den Online-- und Offlinestatus und bietet zwei Komponenten entsprechend des Status den Inhalt rendern. Der folgende Codeausschnitt zeigt eine Verwendung dieser beiden Komponenten. Ist die Anwendung online, wird `you are online` gerendert. Im anderen Fall ~`you are offline`.
%
\begin{center}
\lstinputlisting[language=REACT,caption={Beispiel einer React Detect Offline Implementierung}, label=code:react-detect]{code/Header.js}
\end{center}
%
Das Modul fragt alle fünf Sekunden die URL \url{https://ipv4.icanhazip.com} ab und rendert je nach Verbindungsstatus die entsprechende Komponente. Verschiedene Parameter wie die URL oder das Poll--Interval können konfiguriert werden~\cite{react-detect}.\\\\
%
Der Verbindungsstatus kann im Browser geändert werden. Die Prototypen, die im Rahmen dieser Arbeit entwickelt werden, sollen in den Browsern Firefox und Chromium laufen.\\
In Firefox lässt sich der Netzwerkstatus über das Einstellungsmenü ändern. Dort kann man entweder unter dem Punkt `Sonstiges` oder dem Punkt `Web-Entwickler` `Offline arbeiten` auswählen und ist vom Internet getrennt. Dieser Status lässt sich über den selben Weg rückgängig machen.\\
In Chrome öffnet man dazu die Entwicklertools, geht auf `Netzwerk` und klickt auf die Checkbox `Offline` am oberen Rand. Dieselbe Checkbox ist auch im `Application`--Tab unter `Service Workers` zu finden.
%
% UI
%
\input{chapters/6konzept/UI}
%
% Testfälle
%
\input{chapters/6konzept/testfaelle}