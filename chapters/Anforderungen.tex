\chapter{\label{chap:anforderungen}Anforderungsdefinition}
Dieses Kapitel beschreibt die Anforderungen an eine Offline First Anwendung unter Berücksichtigung von Konfliktmanagement und Funktionalität. \todo{UI auch mit rein?}
Aus den oben genannten \hyperref[chap:szenarien]{Szenarien} werden im Folgenden die Anwendungsfälle und Anforderungen hergeleitet, die eine offlinefähige Anwendung erfüllen soll.
%
% Use Cases  \hyperref[sec:conflict]{oben}
%
\input{chapters/anforderungen/usecase}
%
% Funktionalität
%
\section{Funktionalität}
\highlight{Es soll ein System entwickelt werden, welches an dem Beispiel eines kollaborativen Adressbuchs die Offlinekompatibilität mit dem Schwerpunkt auf das Konfliktmanagement der verwendeten Technologien illustriert.}
\todo{Bezug zu Szenarien und Anwendungsfälle}\\\\
Ein offlinefähiges, kollaboratives Adressbuch zeigt eine Liste von Kontakten, welche jederzeit -- unabhängig von der Internetverbindung -- von den verwendenden Personen gelesen, bearbeitet, erstellt und gelöscht werden können.
Geschieht eine dieser Operationen offline, werden die Daten bei wieder bestehender Internetverbindung synchronisiert. Im einfachen Fall erfolgt die Synchronisation zwischen der Server und Client. Da die Beispielanwendung kollaborativ ist, erfolgt die sie zwischen allen Beteiligten. Die in Kapitel \ref{chap:szenarien} erarbeiteten Szenarien zeigen auf, Synchronisation erfordert in jedem Fall den Umgang mit Konflikten.\\\\
%
Bein ersten Start der Anwendung müssen, wenn vorhanden, alle Kontakte geladen werden. Sobald sie einmal geladen sind, sollen sie auch offline verfügbar sein.
Damit ein Datensatz, wie zum Beispiel ein Adressbucheintrag, offline erreichbar ist, sollte er wenigstens so lange auf dem Client gespeichert werden, bis er vollständig beim Server angekommen sind. Im aktuellen Anwendungsfall bedeutet das, es gibt zwei Kopien des Adressbucheintrags. Eine auf dem Anwendungsgerät, eine auf dem Server.\\
Danach sollen nur die Einträge geladen werden, die nicht auf dem Gerät existieren.
Die Daten würden sonst doppelt geladen werden, der Server hätte mehr zu arbeiten was wiederum die Antwortzeit verlängern würde.
Der Server muss also in der Lage sein die Einträge zu sortieren und nur bestimmte Einträge zu versenden und die Anwendung muss wissen, welche Daten sie bereits hat. Dazu muss jeder Kontakt mittels einer ID identifiziert werden.\\
Wenn es zwei Kontakteinträge mit derselben ID gibt, muss feststellbar sein, welcher Eintrag der aktuellere ist. Gibt es mehr als zwei Einträge müssen diese sortiert werden, sodass ersichtlich wird welcher der aktuellste oder älteste ist, welcher Eintrag vor oder nach welchem kommt. Dazu muss jeder Kontakt versioniert werden.
%
\sub{Konfliktmanagement}
%

Jeder Fehlerfall muss kommuniziert werden. Wenn es konliktbehaftete Daten gibt muss dies mitgeteilt, und angeboten werden die Konflikte zu lösen.
Konflikte sollen als Teil der Anwendung gespeichert werden und von den NutzerInnen auflösbar sein.


\begin{enumerate}
    % \subitem Operationen müssen dem Objekt/Eintrag zugeordnet werden
  % \item Delta berechnen [alle Kontakte -- lokal existierende Kontakte]

  \item Konflikte treten auf, deswegen müssen sie effizient gespeichert werden
  \item in Baumstruktur? So kann leicht zu einem konfliktfreiem Zustand (nur 1 Knoten) `navigiert` werden
  \item rekursiv lösen?

  \item Kein Datenverlust
\end{enumerate}
\todo{siehe Anforderungen \hyperref[sub:pwa]{PWA}?} Plus kein Datenverlust, und 'just work'
%
% UI
%
\section{User experience? Bedienoberfläche?}
Einfache Liste mit Einträgen, editierbar, bei Konflikt: Dialog: `welche Version möchtest du behalten?`\\
\gls{UI} soll sagen wenn es einen Konflikt gab / gibt und mich entscheiden lassen. Bzw ihn lösen lassen.
Auf keinen Fall selber lösen und mich nichts davon wissen lassen.
Im besten Fall soll die \gls{UI} mir sagen \b{warum} es zum Konflikt gekommen ist.\\
