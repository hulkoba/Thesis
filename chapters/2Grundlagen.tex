\chapter{\label{chap:grundlagen}Grundlagen}
Eine Anwendung, die für den Offline-Gebrauch entwickelt wurde, ist sowohl mit, als auch ohne Internetverbindung vollständig einsatzbereit.\\
Dies erfordert einige Grundvoraussetzungen. Die Daten müssen zuerst auf dem Endgerät gespeichert werden, um offline erreichbar zu sein.
Gibt es eine serverseitige Datenbank, müssen die Daten zwischen Server und Client synchronisiert werden. Ist die Anwendung kollaborativ, muss die Synchronisation zwischen allen Beteiligten stattfinden. Synchronisation erfordert den Umgang mit Konflikten, denn es dürfen auf keinen Fall Daten verloren gehen.\\
Dieses Kapitel beschreibt die grundlegenden Optionen eine Anwendung offlinefähig zu machen, geht im Speziellen auf Konflikte und deren Lösungsstrategien ein. 
%
% Offline-First
%
\section{Offline First}
Offline First heißt, die Bestandteile einer Anwendung so zu verwalten, dass nach der ersten Verwendung keine Internetverbindung mehr notwendig ist um deren grundlegenden Funktionen zu nutzen.\todo{Quelle}\\
Native \Glspl{App} existieren und funktionieren grundsätzlich solange offline, bis sie versuchen online Daten abzurufen.\\
note{Harte, weiche, mittlere Probleme (verschiedene Stufen von offlinefähig??)}\\

Bei einer bestehenden Internetverbindung ist das Laden der Ressourcen aus dem Cache schneller als aus dem Netz. Daten, die zuerst auf dem Endgerät gespeichert werden, gehen auch bei plötzlichen Verbindungsverlust nicht verloren. \todo{Synchronisation!}\\\\
Dieser Abschnitt zeigt die verschiedenen Möglichkeiten der lokalen Dateinspeicherung und deren Synchronisation mit einer serverseitigen Datenbank auf.
%
% Cache ServiceWorker AppCache
%
\input{chapters/2/cache}
%
% Browser
%
\input{chapters/2/browser}
%
% Sync
%
\sub{Datenbanksynchronisation}
Im Allgemeinen ist ein Synchronisationsprotokoll die Möglichkeit für zwei Partenen, beispielsweise Client und Server, den Zustand voneinander zu kennen. Der Client schickt seine Daten an den Server und umgekehrt, Konflikte werden gelöst, solange bis beide Parteien denselben Zustand haben.
Leider sind Synchronisationsprotokolle schwer zu implementieren und führen häufig zu einem frustrierenden Ergebnis: Dokumente oder Fotos werden nicht repliziert, es gibt doppelte oder verlorene Daten und alle möglichen Arten von Fehlverhalten bei kollaborativen Anwendungen.\\
CouchDB hat ein intergiertes \hyperref[sec:replication]{Replikationsprotokoll}, das diesen Teil behandelt.  
%
% Couch
%
\subsub{\label{sec:couch}CouchDB}
Apache CouchDB\tm ist ein \gls{DBMS} das seit 2005 als freie Software entwickelt wird. Die dokumentenorientierte \gls{DB} funktioniert sowohl als einzelne Instanz, als auch im Cluster, in dem ein Datenbanksserver auf einer beliebig großen Anzahl an Servern oder Virtuellen Masschinen ausgeführt werden kann.\\
% So kann die Datenschicht beliebig skaliert werden, um die Anforderungen vieler BenutzerInnen zu erfüllen.
CouchDB verwendet das \gls{HTTP}--Protokoll und \gls{JSON} als Datenformat, weswegen es mit jeder Webfähigen Anwendung kompatibel ist. CouchDB wird über ein \gls{REST}ful \gls{HTTP} \gls{API} angesprochen. So können Daten über die für den \gls{REST}ful Services standardisierten Methoden wie zum Beispiel GET, POST, PUT, DELETE abgerufen oder manipuliert werden.\\\\
Das implementierte Replikationsmodell erlaubt die Synchronisation bzw. bidirektionale Replikation zu verschiedenen Geräten, was das besondere Merkmal von CouchDB ist. 
Die genaue Funktionsweise des Protokolls wird in \autoref{sec:replication} detailliert beschrieben.\\
Dieses Protokoll ist die Grundlage für Offline First Anwendungen.
Dank des Replikations--\gls{API} kann kann sich eine CouchDB kontinuierlich und eigenständig mit einer anderen Datenbank die dasselbe Protokoll implementiert, synchronisieren.
Wenn Konflikte auftreten, beispielsweise durch gleichzeitiges Bearbeiten eines Dokuments von zwei Personen ohne Netzwerkverbindung, werden diese als solche markiert, jedoch nicht von selbst aufgelöst~\cite{couch}. Die Lösung der Konflikte muss in der Anwendung implementiert sein.
So kann gewährleistet werden, dass keinerlei Daten verloren gehen.\\\\
CouchDB ist für Server konzipiert. Für Browser gibt es \hyperref[sub:pouch]{PouchDB} und für native iOS- und Android--\glspl{App} wurde Couchbase Lite entwickelt. Alle verwenden das CouchDB Replikationsprotokoll und können Daten miteinander replizieren und~\cite{couch}.
%
% Pouch
%
\subsub{\label{sub:pouch}PouchDB}
\todo{Was benutzt Poch wann? -- IndexedDB, Web SQL, LevelDB}
Als Ergänzung zu CouchDB kann PouchDB verwendet werden. PouchDB ist eine quelloffene JavaScript--Datenbank, die so konzipiert wurde, dass sie im Browser läuft.
PouchDB ermöglicht es Anwendungen zu erstellen, die sowohl offline als auch online funktionieren.
Daten können lokal gespeichert werden, sodass alle Funktionen der Anwendung auch im Offline--Modus zur Verfügung stehen.
Daten werden unabhängig von der nächsten Anmeldung (des nächsten Onlinezugangs) zwischen \b{Clients}, CouchDB oder kompatiblen Servern synchronisiert.
PouchDB läuft auch in Node.js\footnote{JavaScript Laufzeitumgebung, steht unter \url{https://nodejs.org/en/download/} zum Download bereit} und kann als direkte Schnittstelle zu CouchDB--kompatiblen Servern verwendet werden~\cite{pouch}.

% %
% % PWA
% %
% \sub{\label{sub:pwa}Progressive Web Apps \todo{raus?}}
% \Gls{PWA} ist eine Bezeichnung für eine mobil nutzbare Webseite, die eine Brücke zwischen der nativen
% Applikation und einer Webseite schlägt.
% Der Begriff \gls{PWA} wurde im Jahr 2015  von Alex Russel und seiner Frau Frances Berriman geprägt.
% Dieser beschreibt Webseiten, die die positiven Funktionen von nativen Applikationen mitbringen, aber statt über App Stores installiert zu werden, im Webbrowser existieren. Die Webseiteninhalte sind ohne die Installation sofort und jederzeit für die NutzerInnen abrufbar. Schon beim zweiten Besuch der Webseite ist die Ladezeit der Daten verkürzt und sie ist offline, oder auch bei schlechter Internetverbindung nutzbar. Nach mehrmaligem Aufruf kann die \gls{PWA} über den Browser installiert und zum Startbildschirm hinzugefügt werden. Russel und Berriman legen folgende Einenschaften einer \gls{PWA} fest:
% \begin{itemize}
% 	\item Responsive %to fit any form factor
% 	\item Connectivity independen]% Progressively-enhanced with Service Workers to let them work offline
% 	\item App-like-interaction]% Adopt a Shell + Content application model to create appy navigations \& interactions
% 	\item Fresh %Transparently always up-to-date thanks to the Service Worker update process
% 	\item Safe %Served via TLS (a Service Worker requirement) to prevent snooping
% 	\item Discoverable %Are identifiable as “applications” thanks to W3C Manifests and Service Worker registration scope a llowing search engines to find them
% 	\item Re-engageable %Can access the re-engagement UIs of the OS; e.g. Push Notifications
% 	\item Installable %to the home screen through browser-provided prompts, allowing users to “keep” apps they find most useful without the hassle of an app store
% 	\item Linkable %meaning they’re zero-friction, zero-install, and easy to share. The social power of URLs matters.
% \end{itemize}
% \todo{Näher erläutern?}~\cite{pwa}.

%
% Konflikte
%
\input{chapters/2/conflicts}