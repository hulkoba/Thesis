\chapter{\label{chap:grundlagen}Grundlagen}
Was bedeutet offlinefähig?\\
Native \Glspl{App} existieren und funktionieren grundsätzlich solange offline, bis sie versuchen online Daten abzurufen.
%
% Offline-First
%
\section{Offline First}
Offline First heißt, die Bestandteile einer Anwendung so zu verwalten, dass nach der ersten Verwendung keine Internetverbindung mehr notwendig ist um deren grundlegenden Funktionen zu nutzen.\todo{Quelle}\\
Eine Anwendung, die für den Offline-Gebrauch entwickelt wurde, ist sowohl mit, als auch ohne Internetverbindung vollständig einsatzbereit. Bei einer bestehenden Internetverbindung ist das Laden der Ressourcen aus dem Cache schneller als aus dem Netz. Daten, die zuerst lokal gespeichert werden, gehen auch bei plötzlichen Verbindungsverlust nicht verloren.
% 1. Separate Apps from Data\\
% 2. Deliver App Code (and make it cachable) {appcache \& ServiceWorkers}\\
% 3. Save Data Offline {localStrogare / localForage, IndexedDB, other Wrapper}\\
% 4. Detect Connectivity {navigator.onLine} (Lie-fi)\\
% 5. Sync Data - Build upon existing solutions --CouchDB/PouchDB | remoteStorage\\
\sub{Lokale Speicherung im Cache}
Das Cachen der \gls{Assets} ist der erste Schritt um Daten offline verfügbar zu machen. Browser haben die Möglichkeit, diese Dateien in ihrem Cache zu speichern. Der Browser-Cache ist leider nicht persistent und kann ohne Vorwarnung Daten löschen, wenn das Limit des globalen Cache (Disk Cache) erreicht ist.
\subsub{Appcache}
Um mehr Kontrolle darüber zu bekommen, was wann und für wie lange gespeichert werden soll, wurde der Application Cache (AppCache) zur HTML-Spezifikation hinzugefügt.
Im Juni 2016\footnote{siehe \url{https://github.com/w3c/html/pull/444/commits}} wurde der AppCache wieder aus den Web-Standards entfernt, und wird nicht mehr empfohlen.
In der Theorie stellte sich der Application Cache als einfach anzuwenden und unproblematisch dar. Um eine webbasierte Anwendung offline auszuliefern wurde benötigte es eine Textdatei -- der \tt{cache manifest}-Datei -- mit der Endung \tt{.appcache}. Dort wurden alle Ressourcen aufgelistet, welche der Browser cachen sollte.
Die Datei wurde dann über das \tt{manifest}-Attribut in die \gls{HTML}-Dateien der Webanwendung eingebunden werden.
\lstset{language=HTML,caption={Beispiel einer \gls{HTML}-Datei mit einer Manifest-Attribut Einbindung},label={code:appcache_html}}
\begin{lstlisting}
<!DOCTYPE html>
<html manifest="example.appcache">
  <head>
    <title>Example Application Cache</title>
    <link rel="stylesheet" href="style.css">
    <script src="index.js"></script>
  </head>
  <body>
    ...
  </body>
</html>
\end{lstlisting}
Die über das \tt{manifest}-Attribut eingebundene Cache-Datei kann folgendermaßen aussehen:
\lstset{language=python,caption={Beispiel einer \normalfont{\tt{.appcache}}\itshape{-Datei}},label={code:appcache}}
\begin{lstlisting}
CACHE MANIFEST
# version comment for triggering updates
# v1
style.css
index.js
assets/cat.png
\end{lstlisting}
Alle Seiten, mit dem manifest-Attribut und die, die explizit in der Textdatei beschrieben wurden, wurden vom Browser gespeichert~\cite{appcache}.\\
In der Praxis jedoch zeigten sich zahlreiche Probleme mit dem AppCache. So wurde der Application Cache nur aktualisiert wenn sich der Inhalt der des Manifests geändert hat. Dann mussten alle Dateien neu heruntergeladen werden.
Wurden das Manifest und eine andere Datei geändert, wurden die geänderten Dateien nicht unbedingt erneut gespeichert. Denn wenn der Server zusammen mit den Dateien keine Cache-Header sendete, so speicherte der Browser die Datei nach einem Cache-Header-Wert den er `errät`. So konnte es passieren, dass der Browser annahm, eine Datei brauche keine Aktualisierung und weiterhin die alte, gecachte Version auslieferte~\cite{noappcache}.\\
Als Reaktion auf diese Probleme wurde der Service Worker entworfen.
%
% Service Worker
%
\subsub{Service Worker}
Ein Service Worker ist ein Skript, das zwischen Netzwerk und Browser sitzt und von Letzterem im Hintergrund ausgeführt wird. Die Kernfunktion des Service Workers ist es, Netzwerkanfragen abzufangen um sie zu verarbeiten und im Cache zu verwalten~\cite{serviceworker}.\\
Gegenwärtig besitzen -- bis auf den Internet Explorer -- sämtliche Desktop-Browser, und alle gängigen mobilen Browser eine Unterstützung für Service Worker.
\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{ServiceWorker_all}
  \grayRule
  \caption{Browserkompatibilität für Service Worker, Quelle: ~\cite{caniuse-sw}}
  \label{fig:serviceworker}
\end{figure}
Mit dem Service Worker können wie mit dem App Cache statische Ressourcen sofort beim ersten Besuch der Seite im Cache gespeichert werden. Es lässt sich hierbei unterscheiden, ob die Daten vor der ersten Verwendung, oder später im Cache gespeichert werden sollen. Für den ersten Fall eignen sich statische Inhalte wie Schriften oder JS-Dateien, für den zweiten größere Ressourcen die nicht sofort benötigt werden.\\
Zusätzlich bietet der Service Worker die Möglichkeit auf Interaktionen zu reagieren. Den NutzerInnen kann angeboten werden bestimmt Inhalte der Seite, wie zum Beispiel ein Video, später, bzw. offline anzuschauen. Diese werden dann im Cache gespeichert und sind somit offline verfügbar.
Service Worker erlauben außerdem den Zugriff auf Push-Benachrichtigungen und das Background Sync \gls{API}. Die Hintergrundsynchronisation kann einmalig oder in festgelegten Intervallen stattfinden und ist besonders für nicht dringende Aktualisierungen wertvoll~\cite{offline_cookbook}.
%
%
%
\sub{Lokale Speicherung im Browser}
\subsub{localForage und AsyncStorage}
\subsub{IndexedDB}
\subsub{mobil?}

%
% Anforderungen
%
% \sub{Anforderungen an Offline-First Anwendungen}
% Eine Webanwendung besteht grundsätzlich aus zwei Bestandteilen: \it{\gls{Assets}} und benutzerInnengenerierte Daten.\\
% Um offline nutzbar zu sein, müssen einige Voraussetzungen erfüllt werden.
% \begin{itemize}
%   \item müssen auf dem Endgerät gespeichert werden
%   \item Serverseitige (nicht lokal) Datenbank \&\& Synchronisation zwischen Server ind Client
%   \item Kollaborativ \&\& Sync zwischen allen Beteiligten
%   \item Synchronisation erfordert den Umgang mit Konflikten
%   \item Kein Datenverlust
% \end{itemize}
% \todo{merge mit PWA?}
%
% PWA
%
\sub{\label{sub:pwa}Progressive Web Apps}
\Gls{PWA} ist eine Bezeichnung für eine mobil nutzbare Webseite, die eine Brücke zwischen der nativen
Applikation und einer Webseite schlägt.
Der Begriff \gls{PWA} wurde im Jahr 2015  von Alex Russel und seiner Frau Frances Berriman geprägt.
Dieser beschreibt Webseiten, die die positiven Funktionen von nativen Applikationen mitbringen, aber statt über App Stores installiert zu werden, im Webbrowser existieren. Die Webseiteninhalte sind ohne die Installation sofort und jederzeit für die NutzerInnen abrufbar. Schon beim zweiten Besuch der Webseite ist die Ladezeit der Daten verkürzt und sie ist offline, oder auch bei schlechter Internetverbindung nutzbar. Nach mehrmaligem Aufruf kann die \gls{PWA} über den Browser installiert und zum Startbildschirm hinzugefügt werden. Russel und Berriman legen folgende Einenschaften einer \gls{PWA} fest:
\begin{description}[leftmargin=0.5cm,style=nextline]
    \item[Responsive] to fit any form factor
    \item[Connectivity independent] Progressively-enhanced with Service Workers to let them work offline
    \item[App-like-interactions] Adopt a Shell + Content application model to create appy navigations \& interactions
    \item[Fresh] Transparently always up-to-date thanks to the Service Worker update process
    \item[Safe] Served via TLS (a Service Worker requirement) to prevent snooping
    \item[Discoverable] Are identifiable as “applications” thanks to W3C Manifests and Service Worker registration scope a llowing search engines to find them
    \item[Re-engageable] Can access the re-engagement UIs of the OS; e.g. Push Notifications
    \item[Installable] to the home screen through browser-provided prompts, allowing users to “keep” apps they find most useful without the hassle of an app store
    \item[Linkable] meaning they’re zero-friction, zero-install, and easy to share. The social power of URLs matters.
\end{description}
\todo{Näher erläutern?}~\cite{pwa}.
%
% Konflikte [Jan]
%
\section{\label{sec:conflict}Konflikte}
Verteilte Systeme: Das ist ein mächtiger Begriff für viele Ideen und Konzepten, aber es läuft in der Regel darauf hinaus: Da sind zwei oder mehr Computer, die durch ein Netzwerk verbunden sind und es wird versucht, dass einige der Daten auf beiden Computern gleich aussehen. ==> Ein System das zuverlässig über ein Netzwerk funktioniert.\\
Zwei Geräte, ein Server, über Netzwerk verbunden.\\\\
Spezielle Eigenschaft von Netzwerken: Verbindung kann jederzeit abbrechen:
Acht Irrtümer der verteilten Datenverarbeitung:
% \begin{enumerate}
%   \item Das Netzwerk ist zuverlässig
%   \item Die \gls{Latenz}zeit ist gleich null
%   \item Die Bandbreite ist unendlich
%   \item Das Netzwerk ist (informations)sicher
%   \item Die Netzwerkstruktur wird sich nicht ändern
%   \item Es gibt eineN AdministratorIn
%   \item Die Datentransportkosten sind gleich null
%   \item Das Netzwerk ist homogen
% \end{enumerate}
\begin{description}[leftmargin=0.5cm,style=nextline]
  \item[1. Das Netzwerk ist zuverlässig] ~ Der Strom kann ausfallen oder Glasfaserkabel können kaputt sein --- Das Netzwerk ist nicht zuverlässig.
 \item[2. Die \gls{Latenz} ist gleich null] ~ Glasfaserkabel werden durch Mikrowellen (oder andere Technologien) ersetzt um Millisekunden an Zeit zu sparen. Das würde nicht passieren, wäre die \gls{Latenz} bei null. Es dauert nun mal eine gewisse Zeit(ms) wenn ein Signal eine (geografisch)weite Strecke zurücklegen muss --- Die Latenz ist nicht gleich null.
 \item[3. Die \gls{Bandbreite} ist unendlich] ~ Daten können nicht schneller fließen als die Komponenten die sie verarbeiten (\gls{Middleware}, Datenbank \ldots) --- Die Bandbreite ist nicht unendlich.
 \item[4. Das Netzwerk ist sicher] ~ Der \sc{Heartbeat-bug}\footnote{\url{http://heartbleed.com/} -- Zugriff: 07.04.2018}, der im Jahr 2014 behoben wurde und die Sicherheitslücke im ICE-\gls{WLAN} im Jahr 2016\footnote{\url{https://netzpolitik.org/2016/datenschutz-im-zug-deutsche-bahn-will-sicherheitsluecke-in-neuem-ice-wlan-schliessen/} -- Zugriff: 07.04.2018} sind nur zwei Beispiele die zeigen, dass das Netzwerk nicht sicher ist.
 \item[5. Die Netzwerkstruktur wird sich nicht ändern] ~ Eine Datenbank kann beispielsweise über mehrere Server verteilt sein, die (teilweise) voneinander abhängig sind. Ein Server mit Abhängigkeiten kann ausfallen, es kann eine Aktualisierung für einen anderen Server geben --- die Struktur ändert sich.
 \item[5. Die Netzwerkstruktur wird sich nicht ändern] ~ Eine Datenbank kann beispielsweise über mehrere Server verteilt sein, die (teilweise) voneinander abhängig sind. Ein Server mit Abhängigkeiten kann ausfallen, es kann eine Aktualisierung für einen anderen Server geben --- die Struktur ändert sich.
 \item[6. Es gibt eineN AdministratorIn] ~ Es kann beliebig viele AdministratorInnen geben.
 \item[7. Die Datentransportkosten sind gleich null] ~ Netflix bezahlte anfang 2014 diversen InternetanbieterInnen dafür, dass Netflix KundInnen bevorzugten Internetzugang haben.
 \item[8. Das Netzwerk ist homogen] ~ Es gibt verschiedene Arten von Netzwer: 3G, 4G, LTE, WiFi. Wird beeinflusst durch Hardware (Smartphone, Tablet, PC, Laptop, Router \ldots)~\cite{fallacies}
\end{description}
\sub{Git}
Beschreiben wie Git Konflikte löst.
\sub{\gls{CAP} Theorem}
%
% Strategien
%
\section{Sync in verteilten Systemen}
Es stellt sich heraus, dass die Implementierung dieser Art von Echtzeit-Zusammenarbeit alles andere als trivial ist.
Im Folgenden werden die drei Strategien \gls{OT}, \gls{CRDT} und \gls{LWW} vorgestellt plus CouchDBs Peplikationsmodell.
%
% Last-write-wins
%
%\input{chapters/2/lww}
\sub{LWW}
\sub{OT}
\sub{CRDT}

%
% Operational Transform
%
%\input{chapters/2/ot}
%
% CRDT
%
%\input{chapters/2/crdt}
%
% Couch Pouch
%
\input{chapters/2/couch}
